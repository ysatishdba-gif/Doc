"""
Contextual Intent Pipeline with Environmental Context Generation

This pipeline performs three main steps:
1. Query Expansion - Expand medical abbreviations and add clinical context
2. Intent Extraction - Extract clinical intents with natures and sub-natures
3. Contextual Environment Generation - Identify WHERE/WHO/WHEN/WHAT/IN_WHAT_SETTING answers are documented

Contextual Facets Generated:
- Document Types: WHERE information is documented (pathology_report, radiology_report, etc.)
- Author Roles: WHO documents the information (pathologist, radiologist, etc.)
- Temporal Scope: WHEN information is documented (diagnostic_period, active_treatment, etc.)
- Content Signals: WHAT validates the information (diagnosis_codes, lab_values, etc.)
- Clinical Setting: IN WHAT SETTING information is documented (inpatient, outpatient, ED, ICU, etc.)

Author: Satish
Date: 2026-02-02
Purpose: Spike for contextual environment generation user story
"""

import json
import re
from datetime import datetime
from typing import Dict, Any, List
from google.cloud import aiplatform
from vertexai.generative_models import GenerativeModel


QUERY_EXPANSION_PROMPT = """
You are an expert medical AI assistant specializing in clinical query expansion.

TASK: Expand the user's query into a comprehensive, detailed clinical description.

INSTRUCTIONS:
1. Expand ALL medical abbreviations to full terms (e.g., HTN â†’ Hypertension, DM â†’ Diabetes Mellitus, SOB â†’ Shortness of Breath)
2. Clarify vague medical terms with specific clinical language
3. Add relevant medical context based on standard clinical practice
4. Identify implicit clinical concepts that should be explicit
5. DO NOT add assumptions beyond reasonable clinical interpretation
6. DO NOT include action verbs like "analyze", "review", "check" unless in original query
7. DO NOT hallucinate information not implied by the query
8. Maintain the original query's intent and scope
9. Make sure the Temporal aspect is relevant to the Query context

EXAMPLES:
- "Pt with DM" â†’ "Patient with Diabetes Mellitus"
- "Check vitals" â†’ "Vital signs measurement including blood pressure, heart rate, temperature, respiratory rate, oxygen saturation"
- "Family hx of heart disease" â†’ "Cardiovascular disease in family including coronary artery disease, myocardial infarction, heart failure"
- "SOB on exertion" â†’ "Shortness of breath on exertion"

Return ONLY valid JSON (no markdown, no explanation):
{{
  "expanded_query": "comprehensive expanded clinical description",
  "abbreviations_expanded": ["list of abbreviations that were expanded"] 
}}

User Input: {query}
"""

INTENT_EXTRACTION_PROMPT = """
You are a clinical intent extraction engine for medical document retrieval.

====================================================
CLINICAL VALIDATION
====================================================

Return this ONLY if query is non-clinical:
{{"is_clinical": false, "reason": "Query is not clinical in nature", "intents": []}}

====================================================
CORE PRINCIPLES
====================================================

**Extraction Philosophy:**
When someone requests clinical information, extract everything needed to fully understand, act upon, or make decisions about that information safely and effectively.

**Guiding Questions:**
1. What is being requested?
2. What contextual information is inseparable from this concept?
3. What would be incomplete or unsafe without?
4. How is this information naturally organized?

**Inseparability Concept:**
Some information types are inherently connected for safety, understanding, or completeness. When extracting one, consider whether the other is contextually necessary.

====================================================
INTENT GENERATION
====================================================

**Analyze the expanded query and identify distinct clinical intents.**

Each intent represents a clinically independent concept that could be documented or understood separately.

Generate as many intents as the expanded query contains. Let the content guide the count.

====================================================
INTENT STRUCTURE
====================================================

For each intent:

1. **intent_title** - What is this about?
2. **description** - What does this represent and why does it matter?
3. **nature** - What is the primary informational purpose? (Format: [Context] / [Purpose])
4. **sub_natures[]** - What are the distinct dimensions of this information?
5. **final_queries[]** - How would this appear in clinical documents?

====================================================
SUB_NATURE DECOMPOSITION
====================================================

**Core Question: "What are the meaningful aspects of this clinical concept?"**

Structure:
{{
  "category_path": "Broad >> Specific >> Detail",
  "atomic_concepts": ["terminal1", "terminal2"]
}}

**CATEGORY_PATH:**
Think of this as organizing information from general to specific. Each level adds meaningful distinction. Use " >> " as the separator.

Consider: "How would I navigate to this information?"

**ATOMIC_CONCEPTS:**
These are the actual data points - the most specific, granular elements at the end of the navigation path.

Consider: "What are the specific pieces of information needed?"

Include all specific details mentioned: exact values, names, dates, measurements, descriptors.

**Key Understanding:**
- category_path = How to get there (the folders)
- atomic_concepts = What's there (the files - be specific)

**Dimension Identification:**
Consider: "What different types of information exist for this concept?"
- Names and identifiers?
- Measurements and quantities?
- Time-related information?
- Location information?
- Characteristics and qualities?
- Relationships and connections?
- Safety-related information?
- People involved?
- Current state or status?
- Surrounding circumstances?

Extract the dimensions that are present and relevant.

**Grouping Logic:**
If multiple pieces of information answer the same type of question, group them in one sub_nature. Build depth in the category_path rather than creating many shallow sub_natures.

====================================================
FINAL_QUERIES: ATOMIC SPECIFICITY
====================================================

**Purpose:**
Generate concise, atomic-level queries that map to precise clinical concepts without generating excessive CUIs.

**Core Insight:**
Long verbose queries generate too many CUIs. Short atomic queries target specific concepts.

Consider the difference:
-  "metformin 500mg twice daily for diabetes management" â†’ generates 10+ CUIs, which is not required
- âœ“ "metformin 500mg" â†’ generates 2-3 focused CUIs
- âœ“ "twice daily dosing" â†’ generates 1-2 CUIs

**Atomic Query Principle:**
Each query should represent ONE atomic clinical concept or a tight pairing of inseparable concepts.

Think: "What's the smallest meaningful unit?"
- A specific medication + dose
- A specific measurement + value
- A specific condition + severity
- A specific procedure + site

**Generation Approach:**

Extract atomic_concepts directly as queries. Keep them SHORT and PRECISE.

**Guiding Questions:**
- What's the core medical term?
- Is there ONE essential modifier (dose, site, severity)?
- Can this be made shorter while staying meaningful?
- Will this generate a focused set of CUIs?

**Query Characteristics:**
- 2-4 words maximum
- One clinical concept per query
- Include only essential modifiers
- Use standard medical terminology
- Each query â†’ 1-3 CUIs ideally

**Natural Reasoning:**
- Shorter = fewer CUIs = more precise matching
- Atomic = focused = findable
- Multiple short queries > one long query
- Coverage through quantity, not length

**Coverage:**
Generate multiple atomic queries per intent. Each atomic_concept should appear in at least one query, but keep each query short and focused.

====================================================
REASONING FRAMEWORK
====================================================

**Before finalizing, consider:**

On Completeness:
- Have all distinct intents in the expanded query been identified?
- For each intent, have all relevant dimensions been extracted?
- Is there information that's inseparable from what was extracted?

On Specificity:
- Are atomic_concepts as specific as possible?
- Have actual values been included, not just categories?
- Are queries detailed enough to be useful?

On Structure:
- Does each sub_nature represent a different type of information?
- Are atomic_concepts truly the most granular elements?
- Is information properly organized?

On Utility:
- Would someone find what they need with these queries?
- Are the queries realistic for clinical documentation?
- Do the queries cover all the important atomic_concepts?

====================================================
OUTPUT FORMAT
====================================================

{{
  "is_clinical": true,
  "reason": "",
  "original_query": "{original_query}",
  "expanded_query": "{expanded_query}",
  "total_intents_detected": <number>,
  "intents": [
    {{
      "intent_title": "<string>",
      "description": "<string>",
      "nature": "<string>",
      "sub_natures": [
        {{
          "category_path": "<Broad >> Specific >> Detail>",
          "atomic_concepts": ["<concept1>", "<concept2>"]
        }}
      ],
      "final_queries": ["<query1>", "<query2>", "<query3>", "..."]
    }}
  ]
}}

User Input: {expanded_query}
Timestamp: {timestamp}
"""


CONTEXTUAL_ENVIRONMENT_PROMPT = """
You are a clinical informatics expert specializing in medical documentation patterns.

TASK: For each clinical intent, identify the contextual environment where answers would be documented.

====================================================
CONTEXT VS NATURE - CRITICAL DISTINCTION
====================================================

**NATURE/SUB-NATURE** = WHAT the intent is about (diagnosis, treatment, medication)
**CONTEXTUAL ENVIRONMENT** = WHERE/WHO/WHEN answers are found (document types, authors, timeframes)

Example:
- Intent: "Glioblastoma Diagnosis History"
- Nature: "Diagnostic Medical History" â† WHAT it is
- Context: "Pathology reports by pathologists during diagnostic workup" â† WHERE it's found

DO NOT confuse these! Context describes the documentation environment, NOT the medical concept.

====================================================
CONTEXTUAL FACETS TO IDENTIFY
====================================================

For each intent, identify:

1. **DOCUMENT TYPES**
   - What types of clinical documents would contain this information?
   - Examples: pathology_report, radiology_report, consultation_note, operative_note, 
     discharge_summary, progress_note, lab_report, medication_order, etc.
   - Think: "Where is this documented in the medical record?"

2. **AUTHOR ROLES**
   - What healthcare provider roles typically document this?
   - Examples: pathologist, radiologist, oncologist, surgeon, nurse, pharmacist, 
     primary_care_physician, specialist, etc.
   - Think: "Who writes this information?"

3. **TEMPORAL SCOPE**
   - What time period is relevant for this information?
   - Categories: 
     * diagnostic_period: Initial workup and diagnosis
     * active_treatment: During ongoing treatment
     * post_treatment: After treatment completion
     * surveillance: Follow-up monitoring
     * acute_event: Emergency or urgent timeframe
     * chronic_management: Long-term ongoing care
     * historical: Past medical history
     * recent: Last 30-90 days
     * longitudinal: Extended time period
   - Think: "When would this be documented?"

4. **CONTENT SIGNALS**
   - What content markers validate this is the right information?
   - Examples: 
     * diagnosis_code_present: ICD codes mentioned
     * procedure_code_present: CPT codes mentioned
     * lab_values_present: Numerical test results
     * imaging_findings: Radiological descriptions
     * medication_names: Drug names mentioned
     * histology_mentioned: Pathological findings
     * vital_signs: BP, HR, temp, RR
     * treatment_plan: Therapeutic recommendations
   - Think: "What confirms this document answers the intent?"

5. **CLINICAL SETTING**
   - Where in the healthcare system is this information documented?
   - Categories:
     * inpatient: Hospital admission, multi-day stay
     * outpatient: Clinic visits, ambulatory care
     * emergency_department: ED/ER visits
     * intensive_care_unit: ICU/critical care
     * surgical_suite: Operating room, perioperative
     * laboratory: Lab setting
     * imaging_center: Radiology department
     * pharmacy: Pharmacy records
     * home_health: Home care documentation
     * telehealth: Virtual visits
     * rehabilitation_facility: Rehab/skilled nursing
   - Think: "In what care setting would this be documented?"

====================================================
INSTRUCTIONS
====================================================

1. For EACH intent provided:
   - Analyze what the intent is asking for
   - Identify document types where this would be found (top 3-5)
   - Identify author roles who would document this (top 3-5)
   - Determine temporal scope (1-2 categories)
   - List content signals that validate relevance (top 3-5)
   - Identify clinical settings where this occurs (top 2-4)

2. Be SPECIFIC but not overly restrictive:
   - Include primary document types, but also consider secondary ones
   - Focus on roles that DIRECTLY document this (not just "anyone who might see it")
   - Temporal scope should reflect when this info is TYPICALLY documented
   - Content signals should be CONCRETE markers, not vague descriptions
   - Settings should reflect WHERE in healthcare system this is documented

3. Think about MEDICAL DOCUMENTATION PATTERNS:
   - Diagnosis â†’ pathology, radiology, specialist consults (outpatient/inpatient)
   - Treatment â†’ treatment plans, orders, progress notes (varies by setting)
   - Labs â†’ lab reports, progress notes (outpatient/inpatient/laboratory)
   - Medications â†’ medication orders, pharmacy notes (outpatient/inpatient/pharmacy)
   - Procedures â†’ operative notes, procedure reports (surgical_suite/outpatient)
   - History â†’ intake forms, consultation notes (outpatient primarily)
   - Emergency care â†’ ED notes, triage assessments (emergency_department)
   - Critical care â†’ ICU flowsheets, intensivist notes (intensive_care_unit)

4. Avoid OVER-CONSTRAINING:
   - Don't require ALL facets to match perfectly
   - Include likely alternatives
   - Consider that documentation varies by institution

====================================================
INPUT
====================================================

Original Query: {original_query}
Expanded Query: {expanded_query}

Extracted Intents:
{intents_json}

====================================================
OUTPUT FORMAT
====================================================

Return valid JSON with this structure:
{{
  "intents_with_context": [
    {{
      "intent_title": "exact title from input",
      "contextual_environment": {{
        "document_types": ["type1", "type2", "type3"],
        "author_roles": ["role1", "role2", "role3"],
        "temporal_scope": ["category1", "category2"],
        "content_signals": ["signal1", "signal2", "signal3"],
        "clinical_setting": ["setting1", "setting2"]
      }}
    }}
  ]
}}

Return ONLY valid JSON (no markdown, no explanation).
"""


# ============================================================================
# PIPELINE CLASS
# ============================================================================


class ContextualIntentPipeline:
    """
    Three-stage pipeline for clinical intent extraction with contextual environment.
    
    Pipeline Flow:
    1. Query Expansion: Expand abbreviations and add clinical context
    2. Intent Extraction: Extract intents, natures, sub-natures, and queries
    3. Contextual Environment: Identify document types, authors, temporal scope, content signals
    """
    
    def __init__(self, project: str, location: str = "us-central1", 
                 model: str = "gemini-1.5-pro-002"):
        """
        Initialize the pipeline with Vertex AI configuration.
        
        Args:
            project: GCP project ID
            location: GCP location (default: us-central1)
            model: Model version to use (default: gemini-1.5-pro-002)
        """
        aiplatform.init(project=project, location=location)
        self.model = GenerativeModel(model)
        self.project = project
        self.location = location
        self.model_name = model
        
    def _call_model(self, prompt: str, temperature: float = 0.0, max_tokens: int = 8096) -> str:
        """
        Call the generative model with given prompt.
        
        Args:
            prompt: Formatted prompt string
            temperature: Sampling temperature (default: 0.0 for deterministic)
            max_tokens: Maximum output tokens
            
        Returns:
            Model response text
        """
        try:
            # Reset session to avoid context carryover
            if hasattr(self.model, "session") and self.model.session is not None:
                self.model.session.reset()
            
            response = self.model.generate_content(
                prompt,
                generation_config={
                    "temperature": temperature,
                    "max_output_tokens": max_tokens,
                    "top_p": 1.0,
                    "top_k": 1,
                    "seed": 34
                }
            )
            return response.text.strip()
        except Exception as e:
            print(f"Error calling model: {str(e)}")
            return "{}"
    
    def _safe_json(self, text: str) -> Dict[str, Any]:
        """
        Parse JSON from model response with multiple fallback strategies.
        
        Args:
            text: Raw model response text
            
        Returns:
            Parsed JSON dictionary or empty dict on failure
        """
        # Remove markdown code blocks if present
        text = re.sub(r'```json\s*', '', text)
        text = re.sub(r'```\s*', '', text)
        text = text.strip()
        
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            # Try to find JSON object
            match = re.search(r'\{.*\}', text, re.DOTALL)
            if match:
                try:
                    return json.loads(match.group(0))
                except:
                    pass
            
            # Try to find JSON array
            match = re.search(r'\[.*\]', text, re.DOTALL)
            if match:
                try:
                    return json.loads(match.group(0))
                except:
                    pass
            
            print(f"Failed to parse JSON from response: {text[:200]}")
            return {}
    
    def _validate_json_structure(self, data: Dict, required_keys: List[str]) -> bool:
        """
        Validate that required keys exist in parsed JSON.
        
        Args:
            data: Parsed JSON dictionary
            required_keys: List of required key names
            
        Returns:
            True if all required keys present, False otherwise
        """
        return all(key in data for key in required_keys)
    
    # ========================================================================
    # STEP 1: Query Expansion
    # ========================================================================
    
    def expand_query(self, query: str) -> Dict[str, Any]:
        """
        Expand medical abbreviations and add clinical context to query.
        
        Args:
            query: Original user query
            
        Returns:
            Dictionary with expanded_query and abbreviations_expanded
        """
        prompt = QUERY_EXPANSION_PROMPT.format(query=query)
        raw_response = self._call_model(prompt)
        data = self._safe_json(raw_response)
        
        if not self._validate_json_structure(data, ["expanded_query"]):
            # Fallback to original query if expansion fails
            return {
                "expanded_query": query,
                "abbreviations_expanded": []
            }
        
        return {
            "expanded_query": data.get("expanded_query", query),
            "abbreviations_expanded": data.get("abbreviations_expanded", [])
        }
    
    # ========================================================================
    # STEP 2: Intent Extraction
    # ========================================================================
    
    def extract_intents(self, original_query: str, expanded_query: str) -> Dict[str, Any]:
        """
        Extract clinical intents with natures, sub-natures, and final queries.
        
        Args:
            original_query: Original user query
            expanded_query: Expanded query from step 1
            
        Returns:
            Dictionary with intents array or non-clinical rejection
        """
        prompt = INTENT_EXTRACTION_PROMPT.format(
            original_query=original_query,
            expanded_query=expanded_query,
            timestamp=datetime.utcnow().isoformat()
        )
        
        # Use higher token limit for complex queries
        raw_response = self._call_model(prompt, max_tokens=8096)
        data = self._safe_json(raw_response)
        
        # Check if query was rejected as non-clinical
        if not data.get("is_clinical", True):
            return {
                "intents": [],
                "total_intents_detected": 0,
                "is_clinical": False,
                "rejected_reason": data.get("reason", "Query is not clinical"),
                "original_query": original_query,
                "expanded_query": expanded_query
            }
        
        if not self._validate_json_structure(data, ["intents"]):
            return {
                "intents": [],
                "total_intents_detected": 0,
                "error": "Failed to extract intents"
            }
        
        # Validate that all intents have final_queries
        intents = data.get("intents", [])
        validated_intents = []
        
        for idx, intent in enumerate(intents):
            if "final_queries" not in intent or not intent["final_queries"]:
                print(f"  Warning: Intent {idx + 1} '{intent.get('intent_title', 'Unknown')}' has no final_queries. Skipping.")
                continue
            
            validated_intents.append(intent)
        
        return {
            "intents": validated_intents,
            "total_intents_detected": data.get("total_intents_detected", len(validated_intents)),
            "is_clinical": True,
            "original_query": data.get("original_query", original_query),
            "expanded_query": data.get("expanded_query", expanded_query)
        }
    
    # ========================================================================
    # STEP 3: Contextual Environment Generation
    # ========================================================================
    
    def generate_contextual_environment(
        self, 
        original_query: str,
        expanded_query: str,
        intents: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Generate contextual environment for each intent.
        
        This identifies WHERE (document types), WHO (author roles), 
        WHEN (temporal scope), and WHAT (content signals) validate answers.
        
        Args:
            original_query: Original user query
            expanded_query: Expanded query
            intents: List of extracted intents with natures/sub-natures
            
        Returns:
            Dictionary with intents_with_context array
        """
        if not intents:
            return {"intents_with_context": []}
        
        # Prepare intents for prompt (without final_queries to reduce tokens)
        intents_for_prompt = []
        for intent in intents:
            intent_data = {
                "intent_title": intent.get("intent_title", ""),
                "description": intent.get("description", ""),
                "nature": intent.get("nature", ""),
                "sub_natures": intent.get("sub_natures", [])
            }
            intents_for_prompt.append(intent_data)
        
        intents_json = json.dumps(intents_for_prompt, indent=2)
        
        prompt = CONTEXTUAL_ENVIRONMENT_PROMPT.format(
            original_query=original_query,
            expanded_query=expanded_query,
            intents_json=intents_json
        )
        
        raw_response = self._call_model(prompt, max_tokens=8096)
        data = self._safe_json(raw_response)
        
        if not self._validate_json_structure(data, ["intents_with_context"]):
            print("Warning: Failed to generate contextual environment")
            return {"intents_with_context": []}
        
        return data
    
    # ========================================================================
    # PIPELINE EXECUTION
    # ========================================================================
    
    def run(self, query: str, verbose: bool = False) -> Dict[str, Any]:
        """
        Run the complete three-stage pipeline.
        
        Args:
            query: User's clinical query
            verbose: Print progress information (default: False)
            
        Returns:
            Dictionary with complete results including intents with contextual environments
        """
        start_time = datetime.utcnow()
        
        if verbose:
            print(f"Original Query: {query}")
        
        # ====================================================================
        # STEP 1: Query Expansion
        # ====================================================================
        expansion_result = self.expand_query(query)
        expanded_query = expansion_result["expanded_query"]
        
        if verbose:
            print(f"Expanded Query: {expanded_query}")
        
        # ====================================================================
        # STEP 2: Intent Extraction
        # ====================================================================
        intent_result = self.extract_intents(query, expanded_query)
        
        # Handle non-clinical queries
        if not intent_result.get("is_clinical", True):
            processing_time = (datetime.utcnow() - start_time).total_seconds()
            
            if verbose:
                print(f"Status: NON-CLINICAL (rejected)")
                print(f"Processing Time: {processing_time:.2f}s\n")
            
            return {
                "original_query": query,
                "expanded_query": expanded_query,
                "is_clinical": False,
                "rejected_reason": intent_result.get("rejected_reason", "Query is not clinical"),
                "intents": [],
                "timestamp": datetime.utcnow().isoformat(),
                "processing_time_seconds": processing_time
            }
        
        intents = intent_result.get("intents", [])
        
        # ====================================================================
        # STEP 3: Generate Contextual Environment
        # ====================================================================
        context_result = self.generate_contextual_environment(
            query, 
            expanded_query, 
            intents
        )
        
        # Merge intents with their contextual environments
        intents_with_context_map = {}
        for ic in context_result.get("intents_with_context", []):
            intents_with_context_map[ic["intent_title"]] = ic.get("contextual_environment", {})
        
        # Build final output with context integrated
        final_intents = []
        for intent in intents:
            intent_with_context = {
                "intent_title": intent.get("intent_title", ""),
                "description": intent.get("description", ""),
                "nature": intent.get("nature", ""),
                "sub_natures": intent.get("sub_natures", []),
                "final_queries": intent.get("final_queries", [])
            }
            
            # Add contextual environment if available
            if intent["intent_title"] in intents_with_context_map:
                intent_with_context["contextual_environment"] = intents_with_context_map[intent["intent_title"]]
            
            final_intents.append(intent_with_context)
        
        # ====================================================================
        # CALCULATE STATISTICS
        # ====================================================================
        total_queries = sum(len(intent.get('final_queries', [])) for intent in intents)
        total_sub_natures = sum(len(intent.get('sub_natures', [])) for intent in intents)
        contexts_generated = len([i for i in final_intents if "contextual_environment" in i])
        
        processing_time = (datetime.utcnow() - start_time).total_seconds()
        
        if verbose:
            print(f"Status: Clinical")
            print(f"Intents: {len(intents)} | Sub-natures: {total_sub_natures} | Queries: {total_queries}")
            print(f"Contextual Environments: {contexts_generated}")
            print(f"Processing Time: {processing_time:.2f}s\n")
        
        return {
            "original_query": query,
            "expanded_query": expanded_query,
            "is_clinical": True,
            "total_intents_detected": len(intents),
            "intents": final_intents,
            "timestamp": datetime.utcnow().isoformat(),
            "processing_time_seconds": processing_time
        }


# ============================================================================
# MAIN EXECUTION
# ============================================================================


if __name__ == "__main__":
    # Configuration
    PROJECT_ID = "your-project-id"  # Replace with your GCP project ID
    MODEL_VERSION = "gemini-1.5-pro-002"
    
    # Initialize pipeline
    pipeline = ContextualIntentPipeline(
        project=PROJECT_ID,
        location="us-central1",
        model=MODEL_VERSION
    )
    
    # Test queries - diverse examples for spike demonstration
    test_queries = [
        "Patient with glioblastoma diagnosis",
        "Recent hemoglobin A1c results",
        "Metformin 500mg dosing history"
    ]
    
    # Process each query
    for idx, query in enumerate(test_queries, 1):
        print(f"\n{'='*80}")
        print(f"Query {idx}/{len(test_queries)}")
        print(f"{'='*80}")
        
        # Run pipeline
        result = pipeline.run(query, verbose=True)
        
        # Save JSON output
        output_filename = f"query_result_{idx}_with_context.json"
        with open(output_filename, 'w') as f:
            json.dump(result, f, indent=2)
        
        print(f"Saved to: {output_filename}")
        
        # Pretty print for demo presentation
        if result.get("is_clinical") and result.get("intents"):
            print(f"\n{'--- DEMO OUTPUT ---':^80}")
            
            for intent_idx, intent in enumerate(result["intents"], 1):
                print(f"\n{'â”€' * 80}")
                print(f"INTENT #{intent_idx}: {intent['intent_title']}")
                print(f"{'â”€' * 80}")
                print(f"Description: {intent['description']}")
                print(f"Nature: {intent['nature']}")
                
                print(f"\nSub-natures ({len(intent.get('sub_natures', []))}):")
                for sn_idx, sn in enumerate(intent.get("sub_natures", []), 1):
                    print(f"  {sn_idx}. {sn['category_path']}")
                    print(f"     Atomic Concepts: {', '.join(sn['atomic_concepts'])}")
                
                # Display contextual environment (the new feature)
                if "contextual_environment" in intent:
                    ctx = intent["contextual_environment"]
                    print(f"\n{'CONTEXTUAL ENVIRONMENT':^80}")
                    print(f"{'â”€' * 80}")
                    print(f"ðŸ“„ Document Types:")
                    for doc_type in ctx.get('document_types', []):
                        print(f"   â€¢ {doc_type}")
                    
                    print(f"\nðŸ‘¤ Author Roles:")
                    for role in ctx.get('author_roles', []):
                        print(f"   â€¢ {role}")
                    
                    print(f"\nâ° Temporal Scope:")
                    for scope in ctx.get('temporal_scope', []):
                        print(f"   â€¢ {scope}")
                    
                    print(f"\nâœ“ Content Signals:")
                    for signal in ctx.get('content_signals', []):
                        print(f"   â€¢ {signal}")
                    
                    print(f"\nðŸ¥ Clinical Setting:")
                    for setting in ctx.get('clinical_setting', []):
                        print(f"   â€¢ {setting}")
                
                print(f"\nFinal Queries ({len(intent.get('final_queries', []))}):")
                for q_idx, q in enumerate(intent.get("final_queries", [])[:5], 1):
                    print(f"  {q_idx}. {q}")
                if len(intent.get("final_queries", [])) > 5:
                    print(f"  ... and {len(intent['final_queries']) - 5} more")
        
        print()  # Blank line between queries
