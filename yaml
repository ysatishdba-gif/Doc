def _group_by_semantic_type_dynamic(self, cuis: List[str]) -> Dict[str, List[str]]:
    """
    Dynamically group CUIs by their semantic type names (STY) from MRSTY table
    This creates natural groupings based on the actual semantic types present
    """
    
    logger.info("Dynamically fetching semantic types for CUIs...")
    
    # Query to get all CUI-STY mappings for input CUIs
    query = f"""
    WITH cui_types AS (
        SELECT DISTINCT 
            CUI,
            TUI,
            STY  -- Semantic Type Name
        FROM `{self.project_id}.{self.dataset_id}.MRSTY`
        WHERE CUI IN UNNEST(@cuis)
    )
    SELECT * FROM cui_types
    ORDER BY STY, CUI
    """
    
    job_config = bigquery.QueryJobConfig(
        query_parameters=[
            bigquery.ArrayQueryParameter("cuis", "STRING", cuis)
        ]
    )
    
    df = self.client.query(query, job_config=job_config).result(timeout=60).to_dataframe()
    
    if df.empty:
        logger.warning("No semantic type information found in MRSTY")
        return {'UNKNOWN': cuis}
    
    # Group CUIs by STY (Semantic Type Name)
    semantic_groups = defaultdict(set)
    cui_to_types = defaultdict(set)
    
    for _, row in df.iterrows():
        cui = row['CUI']
        sty = row['STY']  # Using STY (semantic type name) as group key
        
        semantic_groups[sty].add(cui)
        cui_to_types[cui].add(sty)
    
    # Handle CUIs with multiple semantic types
    # Assign each CUI to only one group (the most specific or first alphabetically)
    final_groups = defaultdict(list)
    
    for cui in cuis:
        if cui not in cui_to_types:
            # CUI not found in MRSTY
            final_groups['UNKNOWN'].append(cui)
        else:
            types = cui_to_types[cui]
            if len(types) == 1:
                # Single semantic type - straightforward assignment
                final_groups[list(types)[0]].append(cui)
            else:
                # Multiple types - choose based on priority
                # Priority: More specific types (longer names) over general ones
                sorted_types = sorted(types, key=lambda x: (-len(x), x))
                final_groups[sorted_types[0]].append(cui)
    
    # Convert to regular dict and log distribution
    result = dict(final_groups)
    
    logger.info(f"Created {len(result)} semantic groups dynamically:")
    for group, group_cuis in sorted(result.items(), key=lambda x: -len(x[1]))[:10]:
        logger.info(f"  {group}: {len(group_cuis)} CUIs")
    
    if len(result) > 10:
        logger.info(f"  ... and {len(result) - 10} more groups")
    
    return result
