# %% [24] Boost impact analysis — how much does token overlap drive the cut?
# Uses system.fetcher._cache to access metadata
_meta_cache = system.fetcher._cache._d  # access cached metadata
for result in results:
    query_tokens = tokenize_term(normalize_term(result.context_string))
    if not query_tokens:
        log("No query tokens")
        continue

    zero_overlap_kept = 0
    zero_overlap_removed = 0

    # check kept CUIs
    zero_kept_list = []
    for entry in result.retention:
        m = _meta_cache.get(entry.cui)
        cui_tokens = m.all_tokens if m else frozenset()
        overlap = len(query_tokens & cui_tokens)
        if overlap == 0:
            zero_overlap_kept += 1
            zero_kept_list.append((entry.cui, entry.term, entry.alignment))

    # check removed CUIs
    rel_removed = [a for a in result.audit_trail if a.reason == "below_relevance_threshold"]
    for a in rel_removed:
        m = _meta_cache.get(a.removed_cui)
        cui_tokens = m.all_tokens if m else frozenset()
        overlap = len(query_tokens & cui_tokens)
        if overlap == 0:
            zero_overlap_removed += 1

    log(f"\n-- Boost Impact Analysis --")
    log(f"  Query tokens: {query_tokens}")
    log(f"  Kept: {len(result.retention)} ({zero_overlap_kept} with ZERO token overlap)")
    log(f"  Removed: {len(rel_removed)} ({zero_overlap_removed} with ZERO token overlap)")

    # show kept CUIs with zero overlap — these survived on alignment alone
    log(f"\n-- KEPT with zero overlap (survived on alignment only — verify these) --")
    for cui, term, align in zero_kept_list[:15]:
        log(f"  {cui} | align={align} | {term}")
    if len(zero_kept_list) > 15:
        log(f"  ... {len(zero_kept_list) - 15} more")

    # show removed CUIs with HIGH alignment but low overlap — most likely false removals
    log(f"\n-- REMOVED with high alignment (>0.68) — potential false removals --")
    false_removals = []
    for a in rel_removed:
        try:
            align_val = float(a.detail.split("alignment ")[1].split(",")[0])
        except:
            continue
        if align_val > 0.68:
            false_removals.append((a.removed_cui, a.removed_term, a.detail))
    for cui, term, detail in false_removals[:15]:
        log(f"  {cui} | {detail.split(' < ')[0]} | {term}")
    if len(false_removals) > 15:
        log(f"  ... {len(false_removals) - 15} more")
    if not false_removals:
        log(f"  None — all high-alignment CUIs were kept")
