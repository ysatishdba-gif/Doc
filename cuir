# %% [23] Validate relevance filter — inspect cutoff and borderline CUIs
for result in results:
    rel_removed = [a for a in result.audit_trail if a.reason == "below_relevance_threshold"]
    if not rel_removed:
        log("Relevance filter removed 0 CUIs")
        continue

    cutoff_detail = rel_removed[0].detail
    log(f"Relevance filter: kept {len(result.retention)}, removed {len(rel_removed)}")
    log(f"Cutoff: {cutoff_detail}")

    # bottom 10 survivors
    log(f"\n-- Bottom 10 KEPT (borderline survivors) --")
    for entry in result.retention[-10:]:
        log(f"  {entry.cui} | align={entry.alignment} | {entry.term}")

    # top 10 removed (parse boosted score from detail)
    log(f"\n-- Top 10 REMOVED (closest to cutoff — check these) --")
    def _parse_boosted(detail):
        try:
            return float(detail.split("boosted ")[1].split(" ")[0].rstrip(","))
        except:
            return 0.0
    rel_removed_sorted = sorted(rel_removed, key=lambda a: _parse_boosted(a.detail), reverse=True)
    for a in rel_removed_sorted[:10]:
        log(f"  {a.removed_cui} | {a.detail.split(' < ')[0]} | {a.removed_term}")

    # bottom 10 removed
    log(f"\n-- Bottom 10 REMOVED (most distant — should be noise) --")
    for a in rel_removed_sorted[-10:]:
        log(f"  {a.removed_cui} | {a.detail.split(' < ')[0]} | {a.removed_term}")

    # distribution
    kept_scores = [e.alignment for e in result.retention]
    log(f"\n-- Distribution --")
    log(f"  Kept:    count={len(kept_scores)}  min={min(kept_scores):.4f}  max={max(kept_scores):.4f}  mean={np.mean(kept_scores):.4f}")
    log(f"  Removed: count={len(rel_removed)}")
