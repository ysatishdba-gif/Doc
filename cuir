# %% Extract CUI hierarchy from context graph — run ONCE
import re
import networkx as nx
import pickle
from collections import deque

cui_pattern = re.compile(r'^C\d{5,}$')
suffix_pattern = re.compile(r'^(C\d{5,})-\d+$')

real_cuis = set(n for n in obj.nodes() 
                if isinstance(n, str) and cui_pattern.match(n))

print(f"Real CUIs: {len(real_cuis)}")

hierarchy = nx.DiGraph()
processed = 0

for cui in real_cuis:
    # BFS through descendants — collect base CUIs reached
    visited = set()
    q = deque(obj.successors(cui))
    child_cuis = set()
    
    while q:
        node = q.popleft()
        if node in visited:
            continue
        visited.add(node)
        
        # Is this node a suffixed CUI entry?
        if isinstance(node, str):
            m = suffix_pattern.match(node)
            if m:
                base = m.group(1)
                if base in real_cuis and base != cui:
                    child_cuis.add(base)
            # Also check direct CUI nodes
            if node in real_cuis and node != cui:
                child_cuis.add(node)
        
        for child in obj.successors(node):
            if child not in visited:
                q.append(child)
    
    for child in child_cuis:
        hierarchy.add_edge(cui, child)
    
    processed += 1
    if processed % 5000 == 0:
        print(f"  {processed}/{len(real_cuis)} CUIs processed, "
              f"{hierarchy.number_of_edges()} edges found")

print(f"\nHierarchy extracted:")
print(f"  Nodes: {hierarchy.number_of_nodes()}")
print(f"  Edges: {hierarchy.number_of_edges()}")

# Validate
sample = list(hierarchy.nodes())[:5]
for node in sample:
    parents = list(hierarchy.predecessors(node))[:5]
    children = list(hierarchy.successors(node))[:5]
    print(f"  {node}: parents={parents}, children={children}")

with open("umls_hierarchy.pkl", "wb") as f:
    pickle.dump(hierarchy, f)
print(f"\nSaved: umls_hierarchy.pkl")
