# %% [22] Validate: search for a term across audit + retention
search_term = "knee pain"  # change this to any term fragment
for result in results:
    log(f"\n-- Searching '{search_term}' across pipeline --")

    log(f"\n  SURVIVED (in retention):")
    for entry in result.retention:
        if search_term.lower() in entry.term.lower():
            log(f"    {entry.cui} | align={entry.alignment} | {entry.term}")

    log(f"\n  REMOVED (in audit trail):")
    for a in result.audit_trail:
        if search_term.lower() in a.removed_term.lower():
            log(f"    {a.removed_cui} ({a.removed_term})")
            log(f"      -> kept: {a.kept_cui} ({a.kept_term})")
            log(f"      -> reason: {a.reason} | {a.detail}")

# %% [23] Validate relevance filter — inspect cutoff and borderline CUIs
for result in results:
    # find cutoff from audit trail
    rel_removed = [a for a in result.audit_trail if a.reason == "below_relevance_threshold"]
    if not rel_removed:
        log("Relevance filter removed 0 CUIs")
        continue

    # extract cutoff from first audit entry detail
    cutoff_detail = rel_removed[0].detail
    log(f"Relevance filter: kept {len(result.retention)}, removed {len(rel_removed)}")
    log(f"Cutoff: {cutoff_detail}")

    # bottom 10 survivors (just above cutoff)
    log(f"\n-- Bottom 10 KEPT (borderline survivors) --")
    for entry in result.retention[-10:]:
        log(f"  {entry.cui} | align={entry.alignment} | {entry.term}")

    # top 10 removed (just below cutoff — most likely to be wrong removals)
    log(f"\n-- Top 10 REMOVED (closest to cutoff — check these) --")
    rel_removed_sorted = sorted(rel_removed, key=lambda a: float(
        a.detail.split("alignment ")[1].split(" ")[0]), reverse=True)
    for a in rel_removed_sorted[:10]:
        score = a.detail.split("alignment ")[1].split(" ")[0]
        log(f"  {a.removed_cui} | align={score} | {a.removed_term}")

    # bottom 10 removed (most clearly noise)
    log(f"\n-- Bottom 10 REMOVED (most distant — should be noise) --")
    for a in rel_removed_sorted[-10:]:
        score = a.detail.split("alignment ")[1].split(" ")[0]
        log(f"  {a.removed_cui} | align={score} | {a.removed_term}")

    # distribution summary
    kept_scores = [e.alignment for e in result.retention]
    removed_scores = [float(a.detail.split("alignment ")[1].split(" ")[0]) for a in rel_removed]
    log(f"\n-- Distribution --")
    log(f"  Kept:    min={min(kept_scores):.4f}  max={max(kept_scores):.4f}  mean={np.mean(kept_scores):.4f}")
    log(f"  Removed: min={min(removed_scores):.4f}  max={max(removed_scores):.4f}  mean={np.mean(removed_scores):.4f}")
    log(f"  Gap between lowest kept and highest removed: {min(kept_scores) - max(removed_scores):.4f}")
