# %% Fast IC — single pass, no BFS. ~2-3 min for 2.67M nodes
import pickle
import numpy as np
import networkx as nx
from collections import deque

with open("umls_hierarchy.pkl", "rb") as f:
    hierarchy = pickle.load(f)

total = max(hierarchy.number_of_nodes(), 1)
print(f"Nodes: {total}, Edges: {hierarchy.number_of_edges()}")

# Count descendants bottom-up using reverse topological sort
print("Computing descendant counts...")
desc_count = {n: 0 for n in hierarchy.nodes()}

# Process leaves first, work up
# Use in-degree for reverse topo order via Kahn's algorithm
in_degree = {n: 0 for n in hierarchy.nodes()}
for u, v in hierarchy.edges():
    in_degree[v] = in_degree.get(v, 0) + 1

# Start from leaves (nodes with no children)
q = deque(n for n in hierarchy.nodes() if hierarchy.out_degree(n) == 0)
processed = 0

while q:
    node = q.popleft()
    processed += 1
    
    # Pass my count up to all parents
    for parent in hierarchy.predecessors(node):
        desc_count[parent] += desc_count[node] + 1
        in_degree[parent] -= 1
        if in_degree[parent] == 0:
            q.append(parent)
    
    if processed % 500_000 == 0:
        print(f"  {processed}/{total} done")

# Handle cycles (if any remain)
remaining = total - processed
if remaining > 0:
    print(f"  {remaining} nodes in cycles — assigning desc_count=0")

print("Computing IC scores...")
ic_scores = {}
for node, desc in desc_count.items():
    ic_scores[node] = float(-np.log((desc + 1) / total))

print(f"Done. {len(ic_scores)} IC scores")
with open("ic_precomputed.pkl", "wb") as f:
    pickle.dump(ic_scores, f)
print("Saved: ic_precomputed.pkl")
