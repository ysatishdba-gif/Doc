import json
import re
from datetime import datetime
from typing import Dict, Any, List, Optional, Literal, Tuple

from google import genai
from google.genai import types

from pydantic import BaseModel, Field, field_validator, model_validator


# =============================================================================
# PROMPTS
# =============================================================================

QUERY_EXPANSION_PROMPT = """
You are an expert medical AI assistant specializing in clinical query expansion.

TASK: Expand the user's query into a comprehensive, detailed clinical description.

INSTRUCTIONS:
1. Expand ALL medical abbreviations to full terms (e.g., HTN → Hypertension, DM → Diabetes Mellitus, SOB → Shortness of Breath)
2. Clarify vague medical terms with specific clinical language
3. Add relevant medical context based on standard clinical practice
4. Identify implicit clinical concepts that should be explicit
5. DO NOT add assumptions beyond reasonable clinical interpretation
6. DO NOT include action verbs like "analyze", "review", "check" unless in original query
7. DO NOT hallucinate information not implied by the query
8. Maintain the original query's intent and scope
9. Make sure the temporal aspect is relevant to the query context

Return ONLY valid JSON:
{
  "expanded_query": "comprehensive expanded clinical description",
  "abbreviations_expanded": ["list of abbreviations that were expanded"]
}

User Input: {query}
"""


INTENT_EXTRACTION_PROMPT = """
You are a clinical intent extraction engine for medical document retrieval.

Return this ONLY if query is non-clinical:
{"is_clinical": false, "reason": "Query is not clinical in nature", "intents": []}

Original Query: {original_query}
Expanded Query: {expanded_query}
Timestamp: {timestamp}
"""


# =============================================================================
# INPUT SCHEMA (NEW)
# =============================================================================

class ClinicalQueryInput(BaseModel):
    query: str = Field(..., min_length=1)
    output_format: Literal[
        "intent_extraction",
        "final_queries",
        "nature_breakdown"
    ] = "nature_breakdown"
    verbose: bool = False


# =============================================================================
# OUTPUT SCHEMAS
# =============================================================================

class QueryExpansionOutput(BaseModel):
    expanded_query: str
    abbreviations_expanded: List[str] = Field(default_factory=list)


class SubNature(BaseModel):
    category_path: str
    atomic_concepts: List[str]

    @field_validator("category_path")
    @classmethod
    def normalize_separator(cls, v: str) -> str:
        return re.sub(r"\s*(?:>>|>|->|→|/)\s*", " >> ", v).strip()


class Intent(BaseModel):
    intent_title: str
    description: str
    nature: str
    sub_natures: List[SubNature]
    final_queries: List[str]


class IntentWithoutQueries(BaseModel):
    intent_title: str
    description: str
    nature: str
    sub_natures: List[SubNature]


class IntentExtractionOutput(BaseModel):
    is_clinical: bool
    reason: Optional[str] = None
    original_query: str
    expanded_query: str
    total_intents_detected: int
    intents: List[Intent] = Field(default_factory=list)

    @model_validator(mode="after")
    def fix_intent_count(self):
        self.total_intents_detected = len(self.intents)
        return self


class IntentSummaryItem(BaseModel):
    intent_title: str
    description: str


class Format1_IntentExtraction(BaseModel):
    user_query: str
    intents: List[IntentSummaryItem]
    is_clinical: bool
    rejected_reason: Optional[str]
    timestamp: str


class Format2_FinalQueries(BaseModel):
    user_query: str
    final_queries: List[str]
    total_queries: int
    is_clinical: bool
    rejected_reason: Optional[str]
    timestamp: str


class Format3_NatureBreakdown(BaseModel):
    is_clinical: bool
    reason: Optional[str]
    original_query: str
    expanded_query: str
    total_intents_detected: int
    intents: List[IntentWithoutQueries]
    timestamp: str


# =============================================================================
# EXTRACTION RESULT CONTAINER
# =============================================================================

class ExtractionResult:

    def __init__(
        self,
        original_query: str,
        expansion: QueryExpansionOutput,
        intents: IntentExtractionOutput,
        processing_time: float,
    ):
        self.original_query = original_query
        self.expansion = expansion
        self.intents = intents
        self.processing_time = processing_time
        self.timestamp = datetime.utcnow().isoformat()

    def to_intent_extraction(self) -> Dict[str, Any]:
        return Format1_IntentExtraction(
            user_query=self.original_query,
            intents=[
                IntentSummaryItem(
                    intent_title=i.intent_title,
                    description=i.description
                )
                for i in self.intents.intents
            ],
            is_clinical=self.intents.is_clinical,
            rejected_reason=self.intents.reason,
            timestamp=self.timestamp,
        ).model_dump()

    def to_final_queries(self) -> Dict[str, Any]:
        queries = [
            q for intent in self.intents.intents for q in intent.final_queries
        ]
        return Format2_FinalQueries(
            user_query=self.original_query,
            final_queries=queries,
            total_queries=len(queries),
            is_clinical=self.intents.is_clinical,
            rejected_reason=self.intents.reason,
            timestamp=self.timestamp,
        ).model_dump()

    def to_nature_breakdown(self) -> Dict[str, Any]:
        return Format3_NatureBreakdown(
            is_clinical=self.intents.is_clinical,
            reason=self.intents.reason,
            original_query=self.intents.original_query,
            expanded_query=self.intents.expanded_query,
            total_intents_detected=self.intents.total_intents_detected,
            intents=[
                IntentWithoutQueries(
                    intent_title=i.intent_title,
                    description=i.description,
                    nature=i.nature,
                    sub_natures=i.sub_natures,
                )
                for i in self.intents.intents
            ],
            timestamp=self.timestamp,
        ).model_dump()


# =============================================================================
# PIPELINE
# =============================================================================

class ContextualIntentPipeline:

    def __init__(self, project: str, location: str, model: str):
        self.client = genai.Client(
            vertexai=True,
            project=project,
            location=location
        )
        self.model_name = model

    def _extract_json(self, response) -> Dict[str, Any]:
        text = response.text if hasattr(response, "text") else str(response)
        text = re.sub(r"```json|```", "", text).strip()
        return json.loads(text)

    def _call_model(self, prompt: str, schema: type[BaseModel], fallback: str):
        try:
            config = types.GenerateContentConfig(
                temperature=0.0,
                max_output_tokens=8192,
                response_mime_type="application/json",
                response_schema=schema,
            )
            response = self.client.models.generate_content(
                model=self.model_name,
                contents=prompt,
                config=config,
            )
            return schema.model_validate(self._extract_json(response))
        except Exception as e:
            if schema is QueryExpansionOutput:
                return QueryExpansionOutput(expanded_query=fallback)
            return IntentExtractionOutput(
                is_clinical=False,
                reason=str(e),
                original_query=fallback,
                expanded_query=fallback,
                total_intents_detected=0,
                intents=[],
            )

    def expand_query(self, query: str) -> QueryExpansionOutput:
        return self._call_model(
            QUERY_EXPANSION_PROMPT.format(query=query),
            QueryExpansionOutput,
            query,
        )

    def extract_intents(self, original: str, expanded: str) -> IntentExtractionOutput:
        return self._call_model(
            INTENT_EXTRACTION_PROMPT.format(
                original_query=original,
                expanded_query=expanded,
                timestamp=datetime.utcnow().isoformat(),
            ),
            IntentExtractionOutput,
            original,
        )

    def extract(self, query: str, verbose: bool = False) -> ExtractionResult:
        start = datetime.utcnow()
        expansion = self.expand_query(query)
        intents = self.extract_intents(query, expansion.expanded_query)
        elapsed = (datetime.utcnow() - start).total_seconds()

        if verbose:
            print(f"Query: {query}")
            print(f"Expanded: {expansion.expanded_query}")
            print(f"Clinical: {intents.is_clinical}")
            print(f"Processing Time: {elapsed:.2f}s\n")

        return ExtractionResult(query, expansion, intents, elapsed)

    # -----------------------------
    # NEW STRUCTURED RUN METHOD
    # -----------------------------
    def run(self, input_data: ClinicalQueryInput) -> Dict[str, Any]:
        result = self.extract(input_data.query, input_data.verbose)

        if input_data.output_format == "intent_extraction":
            return result.to_intent_extraction()
        if input_data.output_format == "final_queries":
            return result.to_final_queries()
        return result.to_nature_breakdown()


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":

    pipeline = ContextualIntentPipeline(
        project=PROJECT_ID,
        location=LOCATION,
        model=MODEL_VERSION,
    )

    predefined_inputs = [
        ClinicalQueryInput(
            query="Patient with DM",
            output_format="nature_breakdown",
            verbose=True,
        ),
        ClinicalQueryInput(
            query="SOB on exertion",
            output_format="final_queries",
        ),
    ]

    for item in predefined_inputs:
        output = pipeline.run(item)
        print(json.dumps(output, indent=2))
